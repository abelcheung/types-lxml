 lxml-stubs/etree/_element.pyi      | 76 +++++++++++++++++++-------------------
 lxml-stubs/etree/_factory_func.pyi |  8 ++--
 lxml-stubs/html/_element.pyi       | 35 ++++++++++--------
 lxml-stubs/objectify/_element.pyi  |  8 ++--
 pyproject.toml                     |  2 +-
 5 files changed, 66 insertions(+), 63 deletions(-)

diff --git a/lxml-stubs/etree/_element.pyi b/lxml-stubs/etree/_element.pyi
index 7e2658c..86a8760 100644
--- a/lxml-stubs/etree/_element.pyi
+++ b/lxml-stubs/etree/_element.pyi
@@ -14,9 +14,9 @@ from typing import (
 )
 
 if sys.version_info >= (3, 11):
-    from typing import Never, Self
+    from typing import Never
 else:
-    from typing_extensions import Never, Self
+    from typing_extensions import Never
 
 if sys.version_info >= (3, 13):
     from typing import deprecated
@@ -73,34 +73,34 @@ class _Element:
     #
     def __delitem__(self, __k: int | slice) -> None: ...
     @overload
-    def __getitem__(self, __x: int) -> Self: ...
+    def __getitem__(self, __x: int) -> _Element: ...
     @overload
-    def __getitem__(self, __x: slice) -> list[Self]: ...
+    def __getitem__(self, __x: slice) -> list[_Element]: ...
     @overload
-    def __setitem__(self, __x: int, __v: Self) -> None: ...
-    # Not using Iterable[Self] here. Note that an element itself
+    def __setitem__(self, __x: int, __v: _Element) -> None: ...
+    # Not using Iterable here. Note that an element itself
     # is considered an Iterable; when used with __setitem__()
     # like elem[:] = new_elem, only subelements within new_elem
     # will be inserted, but not new_elem itself. If there is none,
     # the whole slice would be silently deleted. Though permitted
     # in runtime, this is not an expected behavior.
     @overload
-    def __setitem__(self, __x: slice, __v: Sequence[Self]) -> None: ...
+    def __setitem__(self, __x: slice, __v: Sequence[_Element]) -> None: ...
     def __contains__(self, __o: object) -> bool: ...
     def __len__(self) -> int: ...
     # There are a hoard of element iterators used in lxml, but
     # they only differ in implementation detail and don't affect typing.
-    def __iter__(self) -> Iterator[Self]: ...
-    def __reversed__(self) -> Iterator[Self]: ...
+    def __iter__(self) -> Iterator[_Element]: ...
+    def __reversed__(self) -> Iterator[_Element]: ...
     def set(self, key: _t._AttrName, value: _t._AttrVal) -> None: ...
-    def append(self, element: Self) -> None: ...
+    def append(self, element: _Element) -> None: ...
     # for extend() argument, see __setitem__() for explanation
-    def extend(self, elements: Sequence[Self]) -> None: ...
+    def extend(self, elements: Sequence[_Element]) -> None: ...
     def clear(self, keep_tail: bool = False) -> None: ...
-    def insert(self, index: int, element: Self) -> None: ...
-    def remove(self, element: Self) -> None: ...
+    def insert(self, index: int, element: _Element) -> None: ...
+    def remove(self, element: _Element) -> None: ...
     def index(
-        self, child: Self, start: int | None = None, end: int | None = None
+        self, child: _Element, start: int | None = None, end: int | None = None
     ) -> int: ...
     @overload
     def get(self, key: _t._AttrName) -> str | None: ...
@@ -112,53 +112,53 @@ class _Element:
     #
     # extra Element / ET methods
     #
-    def addnext(self, element: Self) -> None: ...
-    def addprevious(self, element: Self) -> None: ...
-    def replace(self, old_element: Self, new_element: Self) -> None: ...
-    def getparent(self) -> Self | None: ...
-    def getnext(self) -> Self | None: ...
-    def getprevious(self) -> Self | None: ...
-    def getroottree(self) -> _ElementTree[Self]: ...
+    def addnext(self, element: _Element) -> None: ...
+    def addprevious(self, element: _Element) -> None: ...
+    def replace(self, old_element: _Element, new_element: _Element) -> None: ...
+    def getparent(self) -> _Element | None: ...
+    def getnext(self) -> _Element | None: ...
+    def getprevious(self) -> _Element | None: ...
+    def getroottree(self) -> _ElementTree: ...
     @overload
     def itersiblings(
         self, *tags: _t._TagSelector, preceding: bool = False
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
     def itersiblings(
         self,
         *,
         tag: _t._TagSelector | Collection[_t._TagSelector] | None = None,
         preceding: bool = False,
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
-    def iterancestors(self, *tags: _t._TagSelector) -> Iterator[Self]: ...
+    def iterancestors(self, *tags: _t._TagSelector) -> Iterator[_Element]: ...
     @overload
     def iterancestors(
         self, *, tag: _t._TagSelector | Collection[_t._TagSelector] | None = None
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
-    def iterdescendants(self, *tags: _t._TagSelector) -> Iterator[Self]: ...
+    def iterdescendants(self, *tags: _t._TagSelector) -> Iterator[_Element]: ...
     @overload
     def iterdescendants(
         self, *, tag: _t._TagSelector | Collection[_t._TagSelector] | None = None
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
     def iterchildren(
         self, *tags: _t._TagSelector, reversed: bool = False
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
     def iterchildren(
         self,
         *,
         tag: _t._TagSelector | Collection[_t._TagSelector] | None = None,
         reversed: bool = False,
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
-    def iter(self, *tags: _t._TagSelector) -> Iterator[Self]: ...
+    def iter(self, *tags: _t._TagSelector) -> Iterator[_Element]: ...
     @overload
     def iter(
         self, *, tag: _t._TagSelector | Collection[_t._TagSelector] | None = None
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     @overload
     def itertext(
         self, *tags: _t._TagSelector, with_tail: bool = True
@@ -170,10 +170,10 @@ class _Element:
         tag: _t._TagSelector | Collection[_t._TagSelector] | None = None,
         with_tail: bool = True,
     ) -> Iterator[str]: ...
-    makeelement: _t._ElementFactory[Self]
+    makeelement: _t._ElementFactory
     def find(
         self, path: _t._ElemPathArg, namespaces: _t._NSMapArg | None = None
-    ) -> Self | None: ...
+    ) -> _Element | None: ...
     # Original method has no star. If somebody only supplies
     # 'path' and 'default' argument as positional one, it
     # would be misinterpreted as namespaces argument in first
@@ -194,10 +194,10 @@ class _Element:
     ) -> str | _T: ...
     def findall(
         self, path: _t._ElemPathArg, namespaces: _t._NSMapArg | None = None
-    ) -> list[Self]: ...
+    ) -> list[_Element]: ...
     def iterfind(
         self, path: _t._ElemPathArg, namespaces: _t._NSMapArg | None = None
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
     def xpath(
         self,
         _path: _t._AnyStr,
@@ -213,15 +213,15 @@ class _Element:
         expr: str,
         *,
         translator: _CSSTransArg = "xml",
-    ) -> list[Self]: ...
+    ) -> list[_Element]: ...
     @deprecated("Since v2.0 (2008); use list(element) or iterate over element")
-    def getchildren(self) -> list[Self]: ...
+    def getchildren(self) -> list[_Element]: ...
     # Should have been overloaded for accuracy, but we can turn a blind eye
     # for something that is marked deprecated for 15 years
     @deprecated("Since v2.0 (2008); renamed to .iter()")
     def getiterator(
         self, tag: _t._TagSelector | None = None, *tags: _t._TagSelector
-    ) -> Iterator[Self]: ...
+    ) -> Iterator[_Element]: ...
 
 # ET class notation is specialized, indicating the type of element
 # it is holding (e.g. XML element, HTML element or Objectified
diff --git a/lxml-stubs/etree/_factory_func.pyi b/lxml-stubs/etree/_factory_func.pyi
index 290bc57..d02992f 100644
--- a/lxml-stubs/etree/_factory_func.pyi
+++ b/lxml-stubs/etree/_factory_func.pyi
@@ -13,7 +13,7 @@ from .._types import (
 )
 from ..html import HtmlElement
 from ..objectify import ObjectifiedElement, StringElement
-from ._element import _Comment, _ElementTree, _Entity, _ProcessingInstruction
+from ._element import _Comment, _Element, _ElementTree, _Entity, _ProcessingInstruction
 
 def Comment(text: _AnyStr | None = None) -> _Comment: ...
 def ProcessingInstruction(
@@ -41,7 +41,7 @@ Element: _ElementFactory
 # type annotation attribute is modified.
 # OE users need to use E-factory for more flexibility.
 @overload
-def SubElement(  # type: ignore[overload-overlap]
+def SubElement(
     _parent: ObjectifiedElement,
     _tag: _TagName,
     /,
@@ -60,13 +60,13 @@ def SubElement(
 ) -> HtmlElement: ...
 @overload
 def SubElement(
-    _parent: _ET,
+    _parent: _Element,
     _tag: _TagName,
     /,
     attrib: SupportsLaxedItems[str, _AnyStr] | None = None,
     nsmap: _NSMapArg | None = None,
     **_extra: _AnyStr,
-) -> _ET: ...
+) -> _Element: ...
 @overload  # from element, parser ignored
 def ElementTree(element: _ET) -> _ElementTree[_ET]: ...
 @overload  # from file source, custom parser
diff --git a/lxml-stubs/html/_element.pyi b/lxml-stubs/html/_element.pyi
index dd4c9b1..d5ab1d3 100644
--- a/lxml-stubs/html/_element.pyi
+++ b/lxml-stubs/html/_element.pyi
@@ -128,26 +128,29 @@ class HtmlElement(etree.ElementBase):
     # Subclassing of _Element should not go beyond HtmlElement. For example,
     # while children of HtmlElement are mostly HtmlElement, FormElement never
     # contains FormElement as child.
-    @overload
+    @overload  # type: ignore[override]
     def __getitem__(self, __x: int) -> HtmlElement: ...
     @overload
-    def __getitem__(self, __x: slice) -> list[HtmlElement]: ...
-    @overload
+    def __getitem__(self, __x: slice) -> list[HtmlElement]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
+    @overload  # type: ignore[override]
     def __setitem__(self, __x: int, __v: HtmlElement) -> None: ...
     @overload
-    def __setitem__(self, __x: slice, __v: Sequence[HtmlElement]) -> None: ...
+    def __setitem__(self, __x: slice, __v: Sequence[HtmlElement]) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
     def __iter__(self) -> Iterator[HtmlElement]: ...
     def __reversed__(self) -> Iterator[HtmlElement]: ...
-    def append(self, element: HtmlElement) -> None: ...
-    def extend(self, elements: Sequence[HtmlElement]) -> None: ...
-    def insert(self, index: int, element: HtmlElement) -> None: ...
-    def remove(self, element: HtmlElement) -> None: ...
-    def index(
-        self, child: HtmlElement, start: int | None = None, end: int | None = None
+    def append(self, element: HtmlElement) -> None: ...  # type: ignore[override]
+    def extend(self, elements: Sequence[HtmlElement]) -> None: ...  # type: ignore[override]
+    def insert(self, index: int, element: HtmlElement) -> None: ...  # type: ignore[override]
+    def remove(self, element: HtmlElement) -> None: ...  # type: ignore[override]
+    def index(  # pyright: ignore[reportIncompatibleMethodOverride]
+        self,
+        child: HtmlElement,  # type: ignore[override]
+        start: int | None = None,
+        end: int | None = None,
     ) -> int: ...
-    def addnext(self, element: HtmlElement) -> None: ...
-    def addprevious(self, element: HtmlElement) -> None: ...
-    def replace(self, old_element: HtmlElement, new_element: HtmlElement) -> None: ...
+    def addnext(self, element: HtmlElement) -> None: ...  # type: ignore[override]
+    def addprevious(self, element: HtmlElement) -> None: ...  # type: ignore[override]
+    def replace(self, old_element: HtmlElement, new_element: HtmlElement) -> None: ...  # type: ignore[override]
     def getparent(self) -> HtmlElement | None: ...
     def getnext(self) -> HtmlElement | None: ...
     def getprevious(self) -> HtmlElement | None: ...
@@ -203,17 +206,17 @@ class HtmlElement(etree.ElementBase):
         tag: _TagSelector | Collection[_TagSelector] | None = None,
         with_tail: bool = True,
     ) -> Iterator[str]: ...
-    makeelement: _ElementFactory[HtmlElement]
+    makeelement: _ElementFactory[HtmlElement]  # pyright: ignore[reportIncompatibleVariableOverride]
     def find(
         self, path: _ElemPathArg, namespaces: _NSMapArg | None = None
     ) -> HtmlElement | None: ...
-    def findall(
+    def findall(  # type: ignore[override]
         self, path: _ElemPathArg, namespaces: _NSMapArg | None = None
     ) -> list[HtmlElement]: ...
     def iterfind(
         self, path: _ElemPathArg, namespaces: _NSMapArg | None = None
     ) -> Iterator[HtmlElement]: ...
-    def cssselect(
+    def cssselect(  # type: ignore[override]
         self,
         expr: str,
         *,
diff --git a/lxml-stubs/objectify/_element.pyi b/lxml-stubs/objectify/_element.pyi
index 2b8a301..bab6e67 100644
--- a/lxml-stubs/objectify/_element.pyi
+++ b/lxml-stubs/objectify/_element.pyi
@@ -48,7 +48,7 @@ class ObjectifiedElement(ElementBase):
     def addattr(self, tag: _TagName, value: object) -> None: ...
     def countchildren(self) -> int: ...
     def descendantpaths(self, prefix: str | list[str] | None = None) -> list[str]: ...
-    def getchildren(self) -> list[ObjectifiedElement]: ...
+    def getchildren(self) -> list[ObjectifiedElement]: ...  # type: ignore[override]
     def __iter__(self) -> Iterator[ObjectifiedElement]: ...
     def __reversed__(self) -> Iterator[ObjectifiedElement]: ...
     def __getattr__(self, __name: str) -> ObjectifiedElement: ...
@@ -56,10 +56,10 @@ class ObjectifiedElement(ElementBase):
     # converted to DataElement on-the-fly. Same for __setitem__ below.
     def __setattr__(self, __name: str, __value: object) -> None: ...
     def __delattr__(self, __name: str) -> None: ...
-    @overload
+    @overload  # type: ignore[override]
     def __getitem__(self, __k: int) -> ObjectifiedElement: ...
     @overload
-    def __getitem__(self, __k: slice) -> list[ObjectifiedElement]: ...
+    def __getitem__(self, __k: slice) -> list[ObjectifiedElement]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
     @overload
     def __setitem__(self, __k: int, __v: object) -> None: ...
     @overload
@@ -68,7 +68,7 @@ class ObjectifiedElement(ElementBase):
     # TODO Check if _Element methods need overriding
     # CSS selector is not a normal use case for objectified
     # element (and unnecessary), but still usable nontheless
-    def cssselect(
+    def cssselect(  # type: ignore[override]
         self,
         expr: str,
         *,
diff --git a/pyproject.toml b/pyproject.toml
index 5d8b75b..4ba7dbc 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -5,7 +5,7 @@ requires = ['pdm-backend ~= 2.3']
 build-backend = 'pdm.backend'
 
 [project]
-name = 'types-lxml'
+name = 'types-lxml-multi-subclass'
 dynamic = ['version']
 description = 'Complete lxml external type annotation'
 readme = 'README.md'
