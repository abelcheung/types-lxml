- case: cleaner_construct_simple
  main: |
    from lxml.html.clean import clean, Cleaner
    c = Cleaner()
    reveal_type(c)  # N: Revealed type is "lxml.html.clean.Cleaner"
    reveal_type(clean)  # N: Revealed type is "lxml.html.clean.Cleaner"

# Tiresome to test each and every arguments, just pick some
- case: cleaner_construct_goodargs
  parametrized:
    - args: "scripts=False"
    - args: "style=False"
    - args: "meta=False, embedded=False"
    - args: "forms=False"
    - args: "remove_tags={'html', Comment}"
    - args: "remove_unknown_tags=True"
    - args: "add_nofollow=True"
    - args: "safe_attrs_only=False"
    - args: "host_whitelist=['a.com', 'b.net']"
    - args: "whitelist_tags=None"
  main: |
    from lxml.html.clean import Cleaner
    from lxml.etree import Comment
    c = Cleaner({{ args }})

- case: cleaner_construct_badargs
  expect_fail: true
  parametrized:
    - args: "1"
    - args: "badarg=None"
    - args: "style=o"
    - args: "allow_tags=[], remove_unknown_tags=True"
    - args: "page_structure='x'"
  main: |
    from lxml.html.clean import Cleaner
    o: object
    c = Cleaner({{ args }})

- case: cleaner_call
  parametrized:
    - args: root
    - args: tree
  main: |
    from lxml.html.clean import Cleaner
    from lxml.html import HtmlElement
    from lxml.etree import _ElementTree
    c: Cleaner
    root: HtmlElement
    tree: _ElementTree[HtmlElement]
    c({{ args }})

- case: html_funcs_accept_str_and_elem
  parametrized:
    - func: c.clean_html
      args: html=s
      rt: "builtins.str*"
    - func: c.clean_html
      args: b
      rt: "builtins.bytes*"
    - func: c.clean_html
      args: root
      rt: "lxml.html.HtmlElement*"
    - func: c.clean_html
      args: tree
      rt: "lxml.etree._ElementTree*[lxml.html.HtmlElement]"
    - func: clean.clean_html
      args: s
      rt: "builtins.str*"
    - func: clean.clean_html
      args: html=b
      rt: "builtins.bytes*"
    - func: clean.clean_html
      args: root
      rt: "lxml.html.HtmlElement*"
    - func: clean.clean_html
      args: tree
      rt: "lxml.etree._ElementTree*[lxml.html.HtmlElement]"
    - func: clean.autolink_html
      args: s
      rt: "builtins.str*"
    - func: clean.autolink_html
      args: b
      rt: "builtins.bytes*"
    - func: clean.autolink_html
      args: html=root
      rt: "lxml.html.HtmlElement*"
    - func: clean.autolink_html
      args: tree
      rt: "lxml.etree._ElementTree*[lxml.html.HtmlElement]"
    - func: clean.word_break_html
      args: s
      rt: "builtins.str*"
    - func: clean.word_break_html
      args: b
      rt: "builtins.bytes*"
    - func: clean.word_break_html
      args: root
      rt: "lxml.html.HtmlElement*"
    - func: clean.word_break_html
      args: html=tree
      rt: "lxml.etree._ElementTree*[lxml.html.HtmlElement]"
  main: |
    from lxml.html import clean, HtmlElement
    from lxml.etree import _ElementTree
    c: clean.Cleaner
    s: str
    b: bytes
    root: HtmlElement
    tree: _ElementTree[HtmlElement]
    reveal_type({{ func }}({{ args }}))  # N: Revealed type is "{{ rt }}"

- case: html_funcs_noargs
  expect_fail: true
  parametrized:
    - func: c.clean_html
    - func: clean.clean_html
    - func: clean.autolink_html
    - func: clean.word_break_html
  main: |
    from lxml.html import clean
    c: clean.Cleaner
    _ = {{ func }}()

- case: html_funcs_badargs
  expect_fail: true
  parametrized:
    - func: c.clean_html
    - func: clean.clean_html
    - func: clean.autolink_html
    - func: clean.word_break_html
  main: |
    from lxml.html import HtmlElement, clean
    c: Cleaner
    root: HtmlElement
    _ = {{ func }}(None)
    _ = {{ func }}(root, None)
    _ = {{ func }}(badarg=root)

- case: inplace_funcs_noargs
  parametrized:
    - func: autolink
    - func: word_break
  main: |
    from lxml.html.clean import autolink, word_break
    from lxml.html import HtmlElement
    root: HtmlElement
    _ = {{ func }}(root)  # E: "{{ func }}" does not return a value

- case: inplace_funcs_badargs
  expect_fail: true
  parametrized:
    - func: autolink
      args: None
    - func: autolink
      args: "root, 1"
    - func: autolink
      args: "root, badarg=None"
    - func: autolink
      args: "badarg=root"
    - func: autolink
      args: "root, link_regexes=single_re"
    - func: word_break
      args: None
    - func: word_break
      args: "root, 'x'"
    - func: word_break
      args: "root, badarg=None"
    - func: word_break
      args: "badarg=root"
    - func: word_break
      args: "root, link_regexes=single_re"
  main: |
    import re
    from lxml.html.clean import autolink, word_break
    from lxml.html import HtmlElement
    single_re = re.compile('x')
    root: HtmlElement
    {{ func }}({{ args }})

- case: autolink_goodargs
  parametrized:
    - args: link_regexes=link_re
    - args: avoid_elements=avoid_el
    - args: avoid_hosts=avoid_hosts
    - args: avoid_classes=avoid_cls
    - args: link_re
    - args: "link_re, avoid_el"
  main: |
    import re
    from lxml.html.clean import autolink
    from lxml.html import HtmlElement
    link_re = [re.compile('x'), re.compile('x')]
    avoid_el = ('x', 'x')
    avoid_hosts = (re.compile('x'), re.compile('x'))
    avoid_cls = {'x', 'y'}
    root: HtmlElement
    _ = autolink(root, {{ args }})  # E: "autolink" does not return a value

- case: autolink_html_goodargs
  parametrized:
    - args: "html=s, link_regexes=link_re"
    - args: "s, link_re"
    - args: "s, avoid_elements=avoid_el"
    - args: "s, avoid_hosts=avoid_hosts"
    - args: "s, avoid_classes=avoid_cls"
  main: |
    import re
    from lxml.html.clean import autolink_html
    s: str
    link_re = [re.compile('x'), re.compile('x')]
    avoid_el = ('x', 'x')
    avoid_hosts = (re.compile('x'), re.compile('x'))
    avoid_cls = {'x', 'y'}
    reveal_type(autolink_html({{ args }}))  # N: Revealed type is "builtins.str*"

- case: word_break_goodargs
  parametrized:
    - args: "max_width=40"
    - args: "avoid_classes=avoid_cls"
    - args: "break_character='s'"
    - args: 40
  main: |
    import re
    from lxml.html.clean import word_break
    from lxml.html import HtmlElement
    avoid_cls = {'x', 'y'}
    root: HtmlElement
    _ = word_break(root, {{ args }})  # E: "word_break" does not return a value

- case: word_break_html_goodargs
  parametrized:
    - args: "s, 40"
    - args: "s, max_width=40"
    - args: "html=s, avoid_classes=avoid_cls"
    - args: "s, break_character='x'"
  main: |
    import re
    from lxml.html.clean import word_break_html
    s: str
    avoid_cls = {'x', 'y'}
    reveal_type(word_break_html({{ args }}))  # N: Revealed type is "builtins.str*"
